# 3D Hotel Complex Generator - Implementation Plan

## Project Goal
Build a Python tool that procedurally generates **3D-printable hotel complexes** for the
board game "Hotel" (MB Games, 1986). Each complex is a group of 1-6 buildings arranged
on a shared lot/base plate, sharing a coherent architectural style. Output is a set of
**separate STL files** (individual buildings + base plate) that print independently and
assemble together. A web UI allows previewing and customizing complexes.

### Target Scale
```
Individual building height:  20-100mm (2-10cm)
Complex footprint:           20-50mm x 50-100mm (2-5cm x 5-10cm)
Base plate thickness:        2-3mm with chamfered edges
Building-to-base connection: Alignment pegs/recesses (optional)
```

### Reference: Hotel Board Game
The original Hotel board game features themed hotel complexes:
- **Fujiyama** — 3 buildings (pagoda-inspired, varying heights)
- **Royal** — 4 buildings (grand classical, with lampposts)
- **Waikiki** — 5 buildings (tropical resort)
- **President** — 4 buildings (modern government district)
- **Safari** — 3 buildings (lodge-style, low-rise)
- **Taj Mahal** — 3 buildings (ornate, domed)
- **L'Etoile** — 4 buildings (Parisian elegance)
- **Boomerang** — 3 buildings (Australian modern)

Each hotel has buildings of **different heights and footprints** arranged together.
Our generator creates similar multi-building complexes procedurally.

---

## Architecture Overview

```
┌──────────────────────────────────────────────────────────────┐
│                    Web UI (three.js)                          │
│  Style selector → Complex params → GLB preview               │
│  Building count slider → Layout preview → Download STLs      │
└──────────────────────┬───────────────────────────────────────┘
                       │ HTTP API (FastAPI)
┌──────────────────────▼───────────────────────────────────────┐
│                    Python Backend                              │
│  ┌──────────────┐  ┌──────────────┐  ┌────────────────────┐  │
│  │  Style        │  │ Component    │  │   Complex          │  │
│  │  Grammars     │  │ Generators   │  │   Assembly         │  │
│  └──────────────┘  └──────────────┘  └────────────────────┘  │
│  ┌──────────────┐  ┌──────────────┐  ┌────────────────────┐  │
│  │  Layout       │  │ Building     │  │   Validation       │  │
│  │  Engine       │  │ Assembly     │  │   (printability)   │  │
│  └──────────────┘  └──────────────┘  └────────────────────┘  │
│  ┌──────────────┐  ┌──────────────┐  ┌────────────────────┐  │
│  │  manifold3d   │  │  trimesh     │  │   Hotel Presets    │  │
│  │  (geometry)   │  │  (export)    │  │   (named combos)   │  │
│  └──────────────┘  └──────────────┘  └────────────────────┘  │
└──────────────────────────────────────────────────────────────┘
```

### Key Concepts

| Concept | Description |
|---------|-------------|
| **Complex** | A group of 1-6 buildings on a shared base plate |
| **Building** | A single structure generated by a style (existing system) |
| **Layout** | Procedural placement of buildings on a lot (positions + rotations) |
| **Style** | Architectural grammar that generates one building (existing 8 styles) |
| **Preset** | Named hotel combining a style + layout strategy + building count |
| **Base Plate** | Shared foundation slab with alignment features |

---

## Core Libraries

| Library | Version | Purpose | Why |
|---------|---------|---------|-----|
| **manifold3d** | >=3.3.2, <4.0 | CSG geometry engine | Guaranteed watertight output, fast booleans |
| **trimesh** | >=4.0, <5.0 | Mesh I/O & validation | STL/GLB export, watertightness checks |
| **numpy** | >=1.24, <3.0 | Array ops | Required by both above |
| **fastapi** | >=0.100, <1.0 | Web API | Auto-docs, lightweight |
| **uvicorn** | >=0.20 | ASGI server | Run FastAPI |
| **pydantic** | >=2.0, <3.0 | Config models | Param validation, serialization |
| **pydantic-settings** | >=2.0 | Environment config | Server settings from env vars |

---

## Project Structure

```
3d-hotel-generator/
├── pyproject.toml
├── README.md
├── CLAUDE.md
├── plan.md
├── scripts/
│   ├── setup_environment.sh
│   ├── validate_step.py
│   ├── render_hotel.py
│   ├── render_style_grid.py
│   └── critique_hotel.py
├── renders/
├── src/
│   └── hotel_generator/
│       ├── __init__.py
│       ├── errors.py
│       ├── settings.py
│       ├── geometry/
│       │   ├── __init__.py
│       │   ├── primitives.py
│       │   ├── booleans.py
│       │   └── transforms.py
│       ├── components/
│       │   ├── __init__.py
│       │   ├── base.py           # Base slab (individual building)
│       │   ├── wall.py
│       │   ├── window.py
│       │   ├── door.py
│       │   ├── roof.py
│       │   ├── balcony.py
│       │   ├── column.py
│       │   ├── floor_slab.py
│       │   ├── massing.py
│       │   └── facade.py
│       ├── styles/
│       │   ├── __init__.py
│       │   ├── base.py           # HotelStyle ABC + registry + assemble_building()
│       │   ├── modern.py
│       │   ├── classical.py
│       │   ├── art_deco.py
│       │   ├── victorian.py
│       │   ├── mediterranean.py
│       │   ├── tropical.py
│       │   ├── skyscraper.py
│       │   └── townhouse.py
│       ├── layout/                # NEW — complex layout engine
│       │   ├── __init__.py
│       │   ├── engine.py          # LayoutEngine: place N buildings on a lot
│       │   ├── strategies.py      # Layout strategies: row, L, courtyard, cluster, grid
│       │   └── placement.py       # BuildingPlacement dataclass, collision detection
│       ├── complex/               # NEW — complex assembly
│       │   ├── __init__.py
│       │   ├── builder.py         # ComplexBuilder orchestrator
│       │   ├── base_plate.py      # Shared base plate with optional alignment pegs
│       │   └── presets.py         # Named hotel presets (Royal, Fujiyama, etc.)
│       ├── assembly/
│       │   ├── __init__.py
│       │   └── building.py        # HotelBuilder (single building, existing)
│       ├── export/
│       │   ├── __init__.py
│       │   ├── stl.py
│       │   └── glb.py
│       ├── validation/
│       │   ├── __init__.py
│       │   └── checks.py
│       ├── config.py              # BuildingParams + NEW ComplexParams, PresetInfo
│       └── api.py                 # FastAPI: existing + new complex endpoints
├── web/
│   ├── index.html
│   ├── app.js
│   └── style.css
└── tests/
    ├── conftest.py
    ├── test_geometry.py
    ├── test_components.py
    ├── test_config.py
    ├── test_styles.py
    ├── test_assembly.py
    ├── test_export.py
    ├── test_api.py
    ├── test_layout.py             # NEW
    ├── test_complex.py            # NEW
    └── test_presets.py            # NEW
```

---

## What Already Exists (Steps 1-10, Complete)

The following are fully implemented and tested:

- **Geometry primitives** — box, cylinder, cone, extrude, revolve, booleans, transforms
- **Building components** — base, wall, window, door, roof (5 types), balcony, column, floor_slab, facade, massing (6 shapes)
- **8 architectural styles** — Modern, Art Deco, Classical, Skyscraper, Townhouse, Mediterranean, Tropical, Victorian
- **Assembly engine** — HotelBuilder, BuildResult, three-phase CSG assembly
- **Export pipeline** — STL and GLB export via trimesh
- **API server** — FastAPI with /generate, /export/stl, /styles, /preview/png, /health
- **Web UI** — three.js preview, parameter controls, style selector, STL download
- **Validation** — 10-point geometry checklist
- **Rendering** — Headless pyrender with 4-angle captures
- **Critique** — Vision model feedback loop

All existing tests pass. The new steps build ON TOP of this foundation.

---

## New Implementation Steps (in order)

### Step 11: Scale up dimensions + update validation

The existing code generates tiny Monopoly-scale pieces (1-2cm). We need to support
Hotel-game scale (2-10cm per building, complexes up to 5x10cm).

**Changes:**

- **`config.py`** — Update `BuildingParams` defaults:
  - `width`: 8.0 → 30.0 (mm)
  - `depth`: 6.0 → 25.0 (mm)
  - `num_floors`: 4 (keep, but floor_height changes)
  - `floor_height`: 0.8 → 5.0 (mm) — so 4 floors = 20mm, 10 floors = 50mm
  - Remove or raise aspect ratio limit from 8:1 to 15:1

- **`validation/checks.py`** — Update size bounds:
  - "Reasonable size" check: 25x25x30mm → 120x120x120mm
  - "Not too small" check: 3mm → 10mm in at least 2 dimensions

- **`components/base.py`** — Scale base slab parameters:
  - Overhang: 0.5mm → 1.5mm
  - Thickness: 1.2mm → 2.5mm (FDM), 1.0mm → 2.0mm (resin)

- **Component dimensions** — Scale up windows, doors, columns proportionally:
  - Window: 0.3-0.5mm wide → 2-4mm wide, 0.4-0.7mm tall → 3-5mm tall
  - Door: scale up proportionally
  - Column diameter: 0.8mm → 3-5mm
  - Wall thickness: 0.8mm → 1.5-2mm (FDM)

- **`conftest.py`** — Update test fixtures to use new defaults

**Tests:**
- Existing tests updated to work at new scale
- New parameterized test: generate each style at various sizes (20mm, 50mm, 100mm tall)

**Validation gate:** All existing tests pass at new scale.

---

### Step 12: ComplexParams config model + BuildingPlacement

New config models for multi-building complex generation.

**`config.py`** additions:

```python
class BuildingPlacement(BaseModel):
    """Position and sizing of one building within a complex."""
    x: float = 0.0           # X position on lot (mm)
    y: float = 0.0           # Y position on lot (mm)
    rotation: float = 0.0    # Rotation around Z axis (degrees)
    width: float             # Building width (mm)
    depth: float             # Building depth (mm)
    num_floors: int          # Number of floors
    floor_height: float      # Height per floor (mm)
    role: str = "main"       # "main", "wing", "annex", "tower", "pavilion"

class ComplexParams(BaseModel):
    """Parameters for generating a hotel complex."""
    style_name: str                          # Architectural style for all buildings
    num_buildings: int = 3                   # 1-6 buildings
    printer_type: str = "fdm"
    seed: int = 42
    max_triangles: int = 200_000             # Higher budget for complexes
    style_params: dict[str, Any] = {}
    # Layout is computed procedurally from style + num_buildings + seed
    # but can be overridden:
    lot_width: float | None = None           # Auto-computed if None
    lot_depth: float | None = None           # Auto-computed if None
    building_spacing: float = 5.0            # mm between buildings
    # Optional: explicit building placements (overrides procedural layout)
    placements: list[BuildingPlacement] | None = None
    # Named preset (overrides style_name, num_buildings, etc.)
    preset: str | None = None

class ComplexResult:
    """Result of building a hotel complex."""
    buildings: list[BuildResult]             # Individual building results
    base_plate: Manifold                     # Shared base plate geometry
    combined: Manifold                       # All buildings + base merged (for preview)
    lot_width: float
    lot_depth: float
    placements: list[BuildingPlacement]      # Final computed placements
    metadata: dict[str, Any]

class PresetInfo(BaseModel):
    """Named hotel preset metadata for API."""
    name: str                                # e.g., "royal"
    display_name: str                        # e.g., "Royal"
    description: str
    style_name: str                          # e.g., "classical"
    num_buildings: int
    building_roles: list[str]                # e.g., ["main", "wing", "wing", "tower"]
```

**Validators:**
- `num_buildings` must be 1-6
- `building_spacing` must be >= 2mm
- If `placements` provided, length must match `num_buildings`
- If `preset` provided, it must exist in preset registry

**Tests** (`test_config.py` additions):
- Valid ComplexParams accepted
- num_buildings outside 1-6 rejected
- Preset name validated
- BuildingPlacement serialization round-trip

---

### Step 13: Layout engine — procedural building placement

The layout engine decides WHERE to place each building on the lot.
Each architectural style defines its preferred layout strategy.

**`layout/placement.py`:**
```python
@dataclass
class BuildingFootprint:
    """2D footprint of a building on the lot."""
    x: float
    y: float
    width: float
    depth: float
    rotation: float  # degrees

def footprints_overlap(a: BuildingFootprint, b: BuildingFootprint,
                       min_gap: float = 2.0) -> bool:
    """Check if two building footprints overlap or are too close."""

def footprints_fit_lot(footprints: list[BuildingFootprint],
                       lot_width: float, lot_depth: float) -> bool:
    """Check all footprints fit within the lot bounds."""
```

**`layout/strategies.py`:**

Each strategy takes (num_buildings, seed, style_hints) and returns a list of
BuildingPlacement objects.

| Strategy | Description | Used By |
|----------|-------------|---------|
| `row_layout` | Buildings in a line, tallest in center | Skyscraper, Modern |
| `l_layout` | Main building + wing at 90° | Victorian, Tropical |
| `courtyard_layout` | Buildings around 3-4 sides of a courtyard | Mediterranean, Classical |
| `cluster_layout` | Organic grouping around a main building | Tropical, Safari |
| `campus_layout` | Evenly spaced on a grid/path | Modern, Art Deco |
| `hierarchical_layout` | One tall main building + shorter annexes | Skyscraper, Art Deco |

Each strategy:
1. Computes building dimensions based on role (main is bigger, wings are smaller)
2. Positions buildings with at least `building_spacing` gap
3. Varies heights: main building gets more floors, annexes fewer
4. Auto-computes lot dimensions to fit all buildings + margin

**`layout/engine.py`:**
```python
class LayoutEngine:
    def compute_layout(self, params: ComplexParams) -> list[BuildingPlacement]:
        """Compute building placements for a complex."""
        rng = random.Random(params.seed)
        style = STYLE_REGISTRY[params.style_name]
        strategy = style.preferred_layout_strategy()
        placements = strategy(params.num_buildings, rng, ...)
        # Validate: no overlaps, fits lot
        return placements
```

**`styles/base.py` addition:**
```python
class HotelStyle(abc.ABC):
    # ... existing ...
    def preferred_layout_strategy(self) -> str:
        """Return preferred layout strategy name. Override per style."""
        return "row"

    def building_size_distribution(self, num_buildings: int, rng) -> list[dict]:
        """Return relative sizes for N buildings. Override per style."""
        # Default: one main building (100%), rest are 60-80% size
```

**Tests** (`test_layout.py`):
- Each strategy produces non-overlapping placements
- Placements fit within computed lot bounds
- Different seeds produce different layouts
- Single building (num_buildings=1) works for all strategies
- Building count 1-6 produces valid layouts for each strategy

---

### Step 14: Complex builder — multi-building assembly

The ComplexBuilder orchestrates generating multiple buildings and placing them on a lot.

**`complex/builder.py`:**
```python
class ComplexBuilder:
    def __init__(self, settings: Settings):
        self.settings = settings
        self.building_builder = HotelBuilder(settings)
        self.layout_engine = LayoutEngine()

    def build(self, params: ComplexParams) -> ComplexResult:
        """Build a hotel complex.

        1. Resolve preset (if provided) → fills in style, num_buildings, etc.
        2. Compute layout → list of BuildingPlacement
        3. For each placement: generate building via HotelBuilder (NO base)
        4. Translate/rotate each building to its lot position
        5. Generate shared base plate
        6. Create combined manifold (for GLB preview)
        7. Return ComplexResult with individual + combined
        """
```

Key decisions:
- Each building is generated independently via existing `HotelBuilder.build()`
  but with `skip_base=True` (new flag)
- Buildings are translated/rotated to their placement positions
- The base plate is generated separately with cutout recesses for alignment
- The "combined" manifold merges everything (for GLB preview only)
- Individual buildings + base plate are exported as separate STLs

**`complex/base_plate.py`:**
```python
def complex_base_plate(
    lot_width: float,
    lot_depth: float,
    thickness: float = 2.5,
    chamfer: float = 0.5,
    placements: list[BuildingPlacement] | None = None,
) -> Manifold:
    """Generate a base plate for the hotel complex.

    - Rectangular slab with chamfered edges
    - Optional shallow recesses (0.3mm) at each building position for alignment
    - Optional name/logo engraving area
    """
```

**`assembly/building.py` changes:**
- Add `skip_base: bool = False` parameter to `HotelBuilder.build()`
- When `skip_base=True`, don't add base slab (complex will provide shared base)
- No other changes to existing single-building logic

**Tests** (`test_complex.py`):
- ComplexBuilder produces ComplexResult with correct number of buildings
- Each building is non-empty and watertight
- Base plate is non-empty and watertight
- Combined manifold is non-empty
- Buildings don't overlap in the combined manifold
- Different seeds produce different complexes
- Single building complex (num_buildings=1) works

---

### Step 15: Named hotel presets

Presets are named hotel configurations that combine a style + layout + building roles.
Inspired by the original Hotel board game hotels.

**`complex/presets.py`:**

```python
PRESET_REGISTRY: dict[str, HotelPreset] = {}

@dataclass
class HotelPreset:
    name: str                    # e.g., "royal"
    display_name: str            # e.g., "Royal"
    description: str
    style_name: str              # e.g., "classical"
    num_buildings: int
    layout_strategy: str         # e.g., "courtyard"
    building_roles: list[str]    # e.g., ["main", "wing", "wing", "tower"]
    style_params: dict           # Style-specific overrides
    # Relative sizing hints per building role
    size_hints: dict[str, dict]  # role → {width_ratio, depth_ratio, floor_ratio}
```

**Initial presets (8 hotels):**

| Preset | Style | Buildings | Layout | Description |
|--------|-------|-----------|--------|-------------|
| **Royal** | Classical | 4 | courtyard | Grand classical hotel with columned main building, symmetrical wings, clock tower |
| **Fujiyama** | Art Deco | 3 | hierarchical | Pagoda-inspired stepped tower with two lower annexes |
| **Waikiki** | Tropical | 5 | cluster | Beachside resort: main hotel + 4 bungalow/pavilion buildings |
| **President** | Modern | 4 | campus | Government district: main tower + 3 modern office annexes |
| **Safari** | Mediterranean | 3 | l_layout | Safari lodge: main lodge + 2 low-rise guest wings |
| **Taj Mahal** | Victorian | 3 | hierarchical | Ornate main palace + 2 smaller decorated pavilions |
| **L'Etoile** | Townhouse | 4 | row | Parisian row of 4 connected townhouses with mansard roofs |
| **Boomerang** | Skyscraper | 3 | hierarchical | Central skyscraper + 2 mid-rise podium buildings |

**API addition:**
- `GET /presets` — List all named presets with metadata
- Presets can be selected in ComplexParams via `preset: str`

**Tests** (`test_presets.py`):
- All 8 presets registered and have valid metadata
- Each preset generates a valid ComplexResult
- Preset overrides are applied correctly
- Unknown preset name raises InvalidParamsError

---

### Step 16: API endpoints for complex generation

New API endpoints alongside existing single-building endpoints.

**New endpoints:**

```python
@app.post("/complex/generate")
def generate_complex(params: ComplexParams, builder = Depends(get_complex_builder)):
    """Generate a hotel complex and return combined GLB for preview."""
    result = builder.build(params)
    glb_bytes = export_glb_bytes(result.combined)
    metadata = {
        "num_buildings": len(result.buildings),
        "lot_size": [result.lot_width, result.lot_depth],
        "total_triangles": sum(b.triangle_count for b in result.buildings),
        "placements": [p.model_dump() for p in result.placements],
    }
    return Response(content=glb_bytes, headers={"X-Build-Metadata": json.dumps(metadata)})

@app.post("/complex/export")
def export_complex(params: ComplexParams, builder = Depends(get_complex_builder)):
    """Export hotel complex as a ZIP containing separate STL files.

    ZIP contents:
      - base_plate.stl
      - building_01_main.stl
      - building_02_wing.stl
      - ...
      - manifest.json (placements, dimensions, assembly instructions)
    """

@app.get("/presets")
def get_presets():
    """List all named hotel presets."""

@app.post("/complex/preview/png")
def preview_complex_png(params: ComplexParams, angle: str, resolution: int):
    """Render a PNG preview of the complex."""
```

**Existing endpoints preserved:**
- `/generate`, `/export/stl`, `/styles` — still work for single buildings
- `/health` — unchanged

**Tests** (`test_api.py` additions):
- `/complex/generate` returns GLB with metadata
- `/complex/export` returns ZIP with correct file count
- `/presets` returns preset list
- Invalid preset name returns 400

---

### Step 17: Web UI for complex mode

Update the web UI to support both single-building and complex modes.

**New UI elements:**
- **Mode toggle**: "Single Building" / "Hotel Complex" tabs
- **Complex controls** (visible in complex mode):
  - Preset selector dropdown (Royal, Fujiyama, etc.)
  - OR: Style selector + Building count slider (1-6)
  - Spacing slider (2-15mm)
  - Seed slider
  - Printer type selector
- **Preview panel**: Shows combined complex in 3D viewer (same three.js setup)
- **Export**: "Download ZIP" button that fetches `/complex/export`
- **Build info**: Shows building count, lot dimensions, total triangles

**Key changes to `app.js`:**
- `App` class gets `mode` property ("single" | "complex")
- `getComplexParams()` method builds ComplexParams from UI state
- `generate()` routes to `/generate` or `/complex/generate` based on mode
- `downloadSTL()` routes to `/export/stl` or `/complex/export` based on mode
- Preset selector auto-fills style + building count when selected

**`index.html` changes:**
- Add mode toggle tabs
- Add preset selector
- Add building count slider
- Add complex-specific info panel

---

### Step 18: Render and visual critique for complexes

Update rendering scripts to handle complexes.

**`scripts/render_hotel.py` changes:**
- Accept `--complex` flag and `--preset` option
- When rendering a complex: build via ComplexBuilder, render combined manifold
- Camera distance auto-adjusts for larger complex footprint

**`scripts/render_style_grid.py` changes:**
- New mode: render all 8 presets in a grid (instead of / in addition to 8 styles)

**`scripts/critique_hotel.py` changes:**
- Complex critique prompt asks about:
  - Do buildings look like they belong together (style coherence)?
  - Is the layout logical (buildings don't look randomly placed)?
  - Does the complex read as a "hotel" at a glance?
  - Is each building distinct but related?

**Visual feedback loop:**
For each preset, iterate up to 3 times:
1. Render complex from 4 angles
2. Send to vision model for critique
3. Adjust layout parameters / building proportions based on feedback

---

### Step 19: Polish, integration testing, and documentation

- **End-to-end test**: Start API → generate complex → download ZIP → verify STL files
- **Parameterized test**: All 8 presets × both printer types
- **Performance**: Complex generation < 5s for 6 buildings
- **Triangle budget**: Total complex < 200,000 triangles
- **Assembly verification**: Individual STL files fit together when placed per manifest
- **Cross-preset distinctiveness**: Render all 8 presets in grid, critique for uniqueness
- **Update CLAUDE.md**: Add complex-specific commands and troubleshooting
- **Update README**: Reflect hotel complex generator with new dimensions

---

## Layout Strategy Details

### Row Layout
```
┌─────┐  ┌─────┐  ┌─────┐
│  3  │  │  1  │  │  2  │    1 = Main (tallest)
│     │  │     │  │     │    2, 3 = Wings (shorter)
└─────┘  │     │  └─────┘
         └─────┘
```
Buildings in a line. Main building centered and tallest.
Gap = `building_spacing`. Good for: Modern, Skyscraper.

### Courtyard Layout
```
         ┌─────┐
         │  2  │
┌────┐   │     │   ┌────┐
│ 3  │   └─────┘   │ 4  │    1 = Main (front, widest)
└────┘              └────┘    2 = Back building
    ┌───────────┐             3, 4 = Side wings
    │     1     │
    └───────────┘
```
Buildings around 3-4 sides of a courtyard. Good for: Classical, Mediterranean.

### Hierarchical Layout
```
         ┌───┐
         │ 1 │
         │   │               1 = Main (tallest tower)
         │   │               2, 3 = Annexes (shorter, flanking)
    ┌────┘   └────┐
    │  2  │  │  3 │
    └─────┘  └────┘
```
One dominant building with smaller buildings around its base. Good for: Art Deco, Skyscraper.

### Cluster Layout
```
    ┌──┐        ┌──┐
    │ 4│   ┌────┤ 5│
    └──┘   │  1 └──┘         1 = Main (largest)
   ┌──┐    │    │             2-5 = Pavilions (small, scattered)
   │ 2│    └────┘
   └──┘  ┌──┐
         │ 3│
         └──┘
```
Organic grouping with main building surrounded by smaller structures. Good for: Tropical.

### Campus Layout
```
┌─────┐  ┌─────┐
│  1  │  │  2  │
└─────┘  └─────┘             Evenly spaced grid pattern.
┌─────┐  ┌─────┐             Good for: Modern, institutional.
│  3  │  │  4  │
└─────┘  └─────┘
```

### L Layout
```
┌──────────┐
│    1     │
│          │                  1 = Main (L-shaped or rectangular)
└────┬─────┘                  2, 3 = Along the L
     │  2  │
     └──┬──┘
        │ 3│
        └──┘
```
Buildings arranged in an L pattern. Good for: Victorian, Tropical.

---

## Named Preset Details

### Royal (Classical, 4 buildings, courtyard)
- **Main**: Wide classical facade, 5 floors, columns, pediment. Front of courtyard.
- **Back wing**: 4 floors, simpler facade, connects visually to main.
- **Left/right wings**: 3 floors each, narrow, frame the courtyard sides.
- **Extras**: Optional lampposts (resin only) at courtyard corners.

### Fujiyama (Art Deco, 3 buildings, hierarchical)
- **Main tower**: 8 floors, stepped/ziggurat profile, geometric crown.
- **Left annex**: 4 floors, single setback tier, complements tower.
- **Right annex**: 3 floors, matching Art Deco details.

### Waikiki (Tropical, 5 buildings, cluster)
- **Main hotel**: 4 floors, wide, deep overhangs, tropical roof.
- **4 pavilions**: 1-2 floors each, scattered organically, stilt bases.

### President (Modern, 4 buildings, campus)
- **Main tower**: 6 floors, flat roof, penthouse, grid windows.
- **3 annexes**: 3-4 floors each, same modern style, evenly spaced.

### Safari (Mediterranean, 3 buildings, l_layout)
- **Main lodge**: 3 floors, barrel roof, arched windows, wide.
- **Guest wing A**: 2 floors, connected via L-arrangement.
- **Guest wing B**: 2 floors, smallest, at end of L.

### Taj Mahal (Victorian, 3 buildings, hierarchical)
- **Main palace**: 5 floors, turret, bay windows, ornate roofline.
- **Pavilion A**: 3 floors, Victorian details, smaller footprint.
- **Pavilion B**: 2 floors, matching decorative style.

### L'Etoile (Townhouse, 4 buildings, row)
- **4 townhouses**: 4-5 floors each, varying widths, mansard roofs.
- Arranged in a tight row with minimal gaps (shared-wall appearance).
- Each subtly different height for visual rhythm.

### Boomerang (Skyscraper, 3 buildings, hierarchical)
- **Main tower**: 10 floors, curtain wall, crown element.
- **Podium A**: 4 floors, wider, connects to tower base.
- **Podium B**: 3 floors, complements the composition.

---

## 3D Printing Constraints (Updated for Hotel Scale)

### Printer Profiles

```python
FDM_PROFILE = {
    "min_wall_thickness": 1.2,        # mm (thicker at hotel scale)
    "min_feature_size": 0.8,          # mm
    "min_hole_size": 1.0,             # mm
    "min_column_diameter": 2.0,       # mm
    "min_column_width": 1.5,          # mm
    "min_emboss_width": 0.8,          # mm
    "min_emboss_height": 0.3,         # mm
    "min_engrave_width": 0.6,         # mm
    "min_engrave_depth": 0.3,         # mm
    "max_overhang_angle": 45,
    "max_bridge_span": 10.0,          # mm (longer bridges ok at scale)
    "max_aspect_ratio": 8,
    "base_thickness": 2.5,            # mm
    "base_chamfer": 0.5,              # mm
    "cylinder_segments_per_mm": 4,
    "min_cylinder_segments": 12,
    "max_cylinder_segments": 64,
    "use_window_frames": True,        # Now feasible at hotel scale
    "use_individual_balusters": False,
    "use_arched_windows": False,
    "use_dormers": True,              # Now feasible at hotel scale
}

RESIN_PROFILE = {
    "min_wall_thickness": 0.8,
    "min_feature_size": 0.3,
    "min_hole_size": 0.5,
    "min_column_diameter": 1.0,
    "min_column_width": 0.8,
    "min_emboss_width": 0.3,
    "min_emboss_height": 0.15,
    "min_engrave_width": 0.3,
    "min_engrave_depth": 0.15,
    "max_overhang_angle": 55,
    "max_bridge_span": 999.0,
    "max_aspect_ratio": 12,
    "base_thickness": 2.0,
    "base_chamfer": 0.3,
    "cylinder_segments_per_mm": 6,
    "min_cylinder_segments": 16,
    "max_cylinder_segments": 96,
    "use_window_frames": True,
    "use_individual_balusters": True,
    "use_arched_windows": True,
    "use_dormers": True,
}
```

### Boolean Operation Constants (unchanged)
```python
BOOLEAN_OVERSHOOT = 0.1
BOOLEAN_EMBED = 0.1
COPLANAR_OFFSET = 0.01
```

---

## Key Design Decisions (Updated)

### Existing decisions (1-12) preserved from Steps 1-10.

13. **Separate STL files per building** — Each building in a complex exports as its own
    STL, plus a shared base plate STL. This allows printing buildings in different colors
    or on different plates. A ZIP archive bundles them with a manifest.json describing
    assembly positions.

14. **Style-driven layout strategies** — Each architectural style declares its preferred
    layout pattern (row, courtyard, etc.). The layout engine uses the style's strategy
    but the user can override. This means a "Classical" complex naturally arranges in a
    courtyard, while a "Skyscraper" complex uses a hierarchical tower+podium arrangement.

15. **Named presets as curated combinations** — Presets (Royal, Fujiyama, etc.) are thin
    wrappers that pin a style + layout + building count + role distribution. They don't
    introduce new geometry logic — they just configure the existing style + layout systems.

16. **Building roles for size variation** — Each building in a complex has a "role"
    (main, wing, annex, tower, pavilion). The style uses the role to determine relative
    size: main = 100% height/width, wing = 70%, annex = 50%, etc. This creates the
    natural height variation seen in the Hotel board game pieces.

17. **Combined manifold for preview only** — The web UI receives a single merged GLB
    of all buildings + base for preview purposes. For printing, the user downloads a
    ZIP with individual STLs. This avoids the complexity of multi-object GLB handling
    in the web viewer.

18. **Backward-compatible single-building mode** — All existing single-building endpoints
    (`/generate`, `/export/stl`) remain functional. Complex mode is additive, accessed
    via new `/complex/*` endpoints. The web UI offers a mode toggle.

---

## Autonomous Agent Workflow (Updated)

### Per-Step Quality Gates (Steps 11-19)

The `scripts/validate_step.py` will be extended with gates for steps 11-19:

| Step | Gate |
|------|------|
| 11 | All existing tests pass at new scale; validation accepts 100mm-tall building |
| 12 | ComplexParams model validates; BuildingPlacement serializes |
| 13 | All 6 layout strategies produce valid non-overlapping placements |
| 14 | ComplexBuilder generates 3-building complex; each building watertight |
| 15 | All 8 presets generate valid complexes |
| 16 | `/complex/generate` returns GLB; `/complex/export` returns ZIP |
| 17 | Web UI loads in complex mode; preset selector works |
| 18 | Complex renders from 4 angles; critique scores >= 3.5 |
| 19 | All integration tests pass; all presets pass cross-distinctiveness check |

### Visual Feedback Loop for Complexes
After implementing each preset (Step 15):
1. `python scripts/render_hotel.py --preset royal` → 4-angle renders
2. `python scripts/critique_hotel.py --preset royal` → vision model scores:
   - Style coherence (do buildings match?)
   - Layout logic (sensible arrangement?)
   - Hotel recognition (reads as a hotel complex?)
   - Individual building quality
   - Overall aesthetic
3. Iterate up to 3 times per preset

---

## Target Dimensions at Print Scale (Updated)

```
Complex footprint:      20-50mm x 50-100mm (base plate)
Base plate thickness:   2.0-2.5mm
Building height:        20-100mm (2-10cm)
Building footprint:     10-40mm x 10-30mm per building
Floor height:           4-6mm per floor
Window:                 2-4mm wide, 3-5mm tall, 1-2mm deep recess
Wall thickness:         1.2-1.5mm FDM / 0.8mm resin
Column diameter:        2-5mm FDM / 1-3mm resin
Door:                   5-8mm wide, 8-12mm tall
Building spacing:       3-15mm between buildings
```
